-- Добавляем путь к package.path для поиска модулей в gamedata\scripts
package.path = package.path .. ";gamedata\\scripts\\?.lua"

-- Функция для безопасной загрузки модуля
local function safe_require(module_name)
	printf("[DEBUG] [xml_translator] Attempting to load module: %s", module_name)
	local status, result = pcall(require, module_name)
	if status then
		--printf("[DEBUG] [xml_translator] Successfully loaded module: %s", module_name)
		return result
	else
		--printf("[WARNING] [xml_translator] Failed to load module '%s'. Error: %s", module_name, result)
		return nil
	end
end

-- Функция для загрузки переводов из applying_translate
local function load_applying_translations(xml_file_name)
	local applying_translations = {}
	local applying_folder = "gamedata\\scripts\\dynamic_translations"

	-- Извлекаем базовое имя файла без расширения и пути
	local base_name = xml_file_name:match("([^/\\]+)%.xml$")
	if not base_name then
		--printf("[ERROR] [xml_translator] Invalid XML file name: %s", xml_file_name)
		return applying_translations
	end

	-- Формируем имя Lua-файла на основе базового имени XML-файла
	local lua_file_name = applying_folder .. "\\" .. base_name .. ".lua"

	-- Проверяем, существует ли файл
	local file = io.open(lua_file_name, "r")
	if file then
		file:close()
		-- Загружаем модуль
		local translations = safe_require("dynamic_translations." .. base_name)
		if translations then
			applying_translations[base_name] = translations
			printf("[INFO] [xml_translator] Successfully loaded translations from: %s", lua_file_name)
		else
			--printf("[WARNING] [xml_translator] Failed to load translations from: %s", lua_file_name)
		end
	else
		--printf("[INFO] [xml_translator] No applying translations found for: %s", lua_file_name)
	end

	return applying_translations
end

-- Функция для изменения текста в XML
function change_xml_text(xml_obj, translations)
	if not translations then
		printf("[WARNING] [xml_translator] No translations provided for file.")
		return
	end

	printf("[DEBUG] [xml_translator] Applying translations to XML file")

	local found_count = 0
	local missing_count = 0

	for string_id, new_text in pairs(translations) do
		local query = string.format("string[id=%s] > text", string_id)
		printf("[DEBUG] [xml_translator] Querying XML for ID: %s", string_id)

		local res = xml_obj:query(query)
		if res[1] then
			local el = res[1]
			local el_text = xml_obj:getText(el)
			if el_text then
				xml_obj:setText(el, new_text)
				found_count = found_count + 1
				printf("[DEBUG] [xml_translator] Translation applied for ID: %s", string_id)
			else
				printf("[WARNING] [xml_translator] Empty text for ID: %s", string_id)
			end
		else
			printf("[WARNING] [xml_translator] Element not found for ID: %s", string_id)
			missing_count = missing_count + 1
		end
	end

	printf("[INFO] [xml_translator] Translations applied: %d found, %d missing", found_count, missing_count)
end

-- Функция для создания файла с переводами, если он отсутствует в missing_translations_rus
local function ensure_translation_file(xml_file_path, xml_obj)
	printf("[DEBUG] [xml_translator] Ensuring translation file for: %s", xml_file_path)

	-- Извлекаем имя файла без расширения
	local base_name = xml_file_path:match("([^/\\]+)%.xml$")
	if not base_name then
		printf("[ERROR] [xml_translator] Invalid XML file path: %s", xml_file_path)
		return nil
	end

	-- Путь к файлу в missing_translations_rus
	local missing_translation_path = string.format("gamedata\\scripts\\missing_translations_rus\\%s.lua", base_name)
	printf("[DEBUG] [xml_translator] Checking for missing translation file at: %s", missing_translation_path)

	-- Загружаем существующие переводы, если файл уже существует
	local existing_translations = {}
	local missing_file = io.open(missing_translation_path, "r")
	if missing_file then
		printf("[INFO] [xml_translator] Loading existing translations from: %s", missing_translation_path)
		local content = missing_file:read("*a")
		missing_file:close()

		-- Парсим существующие переводы из Lua-файла
		local func, err = load("return " .. content, "translations", "t", {})
		if func then
			local status, result = pcall(func)
			if status and type(result) == "table" then
				existing_translations = result
				printf("[INFO] [xml_translator] Successfully loaded existing translations: %s", result)

				-- Проверяем, пуста ли таблица
				if next(existing_translations) == nil then
					printf("[INFO] [xml_translator] Table is empty: %s", missing_translation_path)
					--os.remove(missing_translation_path) -- Удаляем файл
				end
			else
				printf("[WARNING] [xml_translator] Failed to parse existing translations: %s", result)
			end
		else
			printf("[WARNING] [xml_translator] Failed to load existing translations: %s", err)
		end
	else
		printf("[INFO] [xml_translator] Missing translation file not found: %s", missing_translation_path)
	end

	-- Собираем новые переводы из XML
	local new_translations = {}
	local root = xml_obj:getRoot() -- Получаем корневой элемент XML
	if root then
		printf("[DEBUG] [xml_translator] Root element found: %s", xml_obj:getElementName(root))

		-- Определяем callback-функцию для iterateChildren
		local function process_child(child)
			printf("[DEBUG] [xml_translator] Processing child element: %s", xml_obj:getElementName(child))

			-- Проверяем, является ли элемент тегом <string>
			if xml_obj:isElement(child) and xml_obj:getElementName(child) == "string" then
				printf("[DEBUG] [xml_translator] Found <string> element")

				-- Получаем атрибут id
				local attr_table = xml_obj:getElementAttr(child)
				local string_id = attr_table and attr_table.id
				if string_id then
					printf("[DEBUG] [xml_translator] Found string ID: %s", string_id)

					-- Получаем текст из дочернего элемента <text>
					local text_elements = xml_obj:query("text", child)
					if text_elements and text_elements[1] then
						printf("[DEBUG] [xml_translator] Found <text> element")

						local text = xml_obj:getText(text_elements[1])
						if text then
							printf("[DEBUG] [xml_translator] Found text: %s", text)

							-- Экранируем кавычки в тексте
							text = text:gsub('"', '\\"')

							-- Добавляем только если ID отсутствует в существующих переводах
							if not existing_translations[string_id] then
								new_translations[string_id] = text
								printf("[INFO] [xml_translator] Adding new translation for ID: %s", string_id)
							else
								printf("[INFO] [xml_translator] Skipping existing ID: %s", string_id)
							end
						else
							printf("[WARNING] [xml_translator] Empty <text> element")
						end
					else
						printf("[WARNING] [xml_translator] <text> element not found in <string>")
					end
				else
					printf("[WARNING] [xml_translator] Missing 'id' attribute in <string> element")
				end
			else
				printf("[DEBUG] [xml_translator] Skipping non-<string> element: %s", xml_obj:getElementName(child))
			end
		end

		-- Вызываем iterateChildren с callback-функцией
		xml_obj:iterateChildren(root, process_child)
	else
		printf("[ERROR] [xml_translator] Root element not found in XML")
	end

	-- Если есть новые переводы, обновляем файл
	if next(new_translations) then
		-- Объединяем существующие и новые переводы
		for string_id, text in pairs(new_translations) do
			existing_translations[string_id] = text
		end

		-- Перезаписываем файл с обновленными переводами
		local file = io.open(missing_translation_path, "w")
		if file then
			file:write("-- Translations for " .. base_name .. "\n")
			file:write("{\n")

			-- Записываем все переводы (существующие и новые)
			for string_id, text in pairs(existing_translations) do
				file:write(string.format('    ["%s"] = "%s",\n', string_id, text))
			end

			file:write("}\n")
			file:close()
			printf("[INFO] [xml_translator] Successfully updated translations in: %s", missing_translation_path)
		else
			printf("[ERROR] [xml_translator] Failed to open file for writing: %s", missing_translation_path)
		end
	else
		printf("[INFO] [xml_translator] No new translations to add")
	end
end

-- Callback для обработки XML
function on_xml_read()
	RegisterScriptCallback("on_xml_read", function(xml_file_name, xml_obj)
		printf("[INFO] [xml_translator] Callback triggered for file: %s", xml_file_name)
		if not xml_file_name:match("^text\\eng\\.+%.xml$") and not xml_file_name:match("^text\\rus\\.+%.xml$") then
			return
		end

		local base_name = xml_file_name:match("([^/\\]+)%.xml$")

		local applying_translations = load_applying_translations(xml_file_name)
		if xml_file_name:match("^text\\eng\\.+%.xml$") then
			printf("[DEBUG] [xml_translator] Processing file (in text\\eng): %s", xml_file_name)

			ensure_translation_file(xml_file_name, xml_obj)
		end

		-- Проверяем, что файл находится в text\rus
		if xml_file_name:match("^text\\rus\\.+%.xml$") then
		--if xml_file_name:match("NOT_LOADING") then
			printf("[DEBUG] [xml_translator] Processing file (in text\\rus): %s", xml_file_name)

			if base_name then
				-- Путь к файлу в missing_translations_rus
				local missing_translation_path =
					string.format("gamedata\\scripts\\missing_translations_rus\\%s.lua", base_name)

				-- Загружаем существующие переводы из файла
				local existing_translations = {}
				local file = io.open(missing_translation_path, "r")
				if file then
					local content = file:read("*a")
					file:close()

					-- Парсим содержимое файла в таблицу
					local func, err = load("return " .. content, "translations", "t", {})
					if func then
						local status, result = pcall(func)
						if status and type(result) == "table" then
							existing_translations = result
							printf(
								"[INFO] [xml_translator] Successfully loaded existing translations from: %s",
								missing_translation_path
							)
						else
							printf("[WARNING] [xml_translator] Failed to parse existing translations: %s", result)
						end
					else
						printf("[WARNING] [xml_translator] Failed to load existing translations: %s", err)
					end
				else
					printf("[INFO] [xml_translator] No missing translation file found for: %s", base_name)
				end

				-- Удаляем записи, которые больше не нужны
				local updated_translations = {}
				for string_id, text in pairs(existing_translations) do
					-- Проверяем, есть ли этот string_id в XML-файле
					local query = string.format("string[id=%s] > text", string_id)
					local res = xml_obj:query(query)
					if not res[1] then
						-- Если string_id отсутствует в XML, оставляем его в таблице
						updated_translations[string_id] = text
					else
						--printf("[INFO] [xml_translator] Removed translation for ID: %s", string_id)
					end
				end

				-- Перезаписываем файл с обновленными переводами
				local file = io.open(missing_translation_path, "w")
				if file then
					file:write("-- Translations for " .. base_name .. "\n")
					file:write("{\n")

					-- Записываем оставшиеся переводы
					for string_id, text in pairs(updated_translations) do
						file:write(string.format('    ["%s"] = "%s",\n', string_id, text))
					end

					file:write("}\n")
					file:close()
					printf("[INFO] [xml_translator] Successfully updated translations in: %s", missing_translation_path)
				else
					printf("[ERROR] [xml_translator] Failed to open file for writing: %s", missing_translation_path)
				end
			else
				printf("[ERROR] [xml_translator] Invalid XML file name: %s", xml_file_name)
			end
		end
		if applying_translations and next(applying_translations) ~= nil then
			change_xml_text(xml_obj, applying_translations[base_name])
		end
	end)
end
