-- Добавляем путь к package.path для поиска модулей в gamedata\scripts
package.path = package.path .. ";gamedata\\scripts\\?.lua"

-- Функция для безопасной загрузки модуля
local function safe_require(module_name)
	printf("[DEBUG] [xml_translator] Attempting to load module: %s", module_name)
	local status, result = pcall(require, module_name)
	if status then
		--printf("[DEBUG] [xml_translator] Successfully loaded module: %s", module_name)
		return result
	else
		--printf("[WARNING] [xml_translator] Failed to load module '%s'. Error: %s", module_name, result)
		return nil
	end
end

-- Функция для загрузки переводов из applying_translate
local function load_applying_translations(xml_file_name)
	local applying_translations = {}
	local applying_folder = "gamedata\\scripts\\dynamic_translations"

	-- Извлекаем базовое имя файла без расширения и пути
	local base_name = xml_file_name:match("([^/\\]+)%.xml$")
	if not base_name then
		--printf("[ERROR] [xml_translator] Invalid XML file name: %s", xml_file_name)
		return applying_translations
	end

	-- Формируем имя Lua-файла на основе базового имени XML-файла
	local lua_file_name = applying_folder .. "\\" .. base_name .. ".lua"

	-- Проверяем, существует ли файл
	local file = io.open(lua_file_name, "r")
	if file then
		file:close()
		-- Загружаем модуль
		local translations = safe_require("dynamic_translations." .. base_name)
		if translations then
			applying_translations[base_name] = translations
			printf("[INFO] [xml_translator] Successfully loaded translations from: %s", lua_file_name)
		else
			--printf("[WARNING] [xml_translator] Failed to load translations from: %s", lua_file_name)
		end
	else
		--printf("[INFO] [xml_translator] No applying translations found for: %s", lua_file_name)
	end

	return applying_translations
end

-- Функция для получения перевода по имени файла
function get_translations_for_file(xml_file_name, applying_translations)
	--printf("[DEBUG] [xml_translator] Getting translations for file: %s", xml_file_name)

	-- Извлекаем имя файла без расширения
	local base_name = xml_file_name:match("([^/\\]+)%.xml$")
	if not base_name then
		--printf("[ERROR] [xml_translator] Invalid XML file name: %s", xml_file_name)
		return nil
	end

	-- Проверяем, есть ли переводы в applying_translate
	if applying_translations[base_name] then
		--printf("[INFO] [xml_translator] Using translations from applying_translate for: %s", base_name)
		return applying_translations[base_name]
	end

	-- Если переводов в applying_translate нет, загружаем из gamedata/configs/text/rus
	local rus_file_path = xml_file_name:gsub("text\\eng", "gamedata\\configs\\text\\rus")
	printf("[DEBUG] [xml_translator] Loading translations from: %s", rus_file_path)
	--ИСПРАВИТЬ
	local translations = safe_require(rus_file_path:gsub("text\\rus\\", ""):gsub("%.xml$", ""))
	printf(translations)
	if translations then
		printf("[DEBUG] [xml_translator] Translations loaded successfully for: %s", xml_file_name)
	else
		--printf("[WARNING] [xml_translator] No translations found for file: %s", xml_file_name)
	end

	return translations
end

-- Функция для изменения текста в XML
function change_xml_text(xml_obj, translations)
	if not translations then
		--printf("[WARNING] [xml_translator] No translations provided for file.")
		return
	end

	--printf("[DEBUG] [xml_translator] Applying translations to XML file")

	local found_count = 0
	local missing_count = 0

	for string_id, new_text in pairs(translations) do
		local query = string.format("string[id=%s] > text", string_id)
		--printf("[DEBUG] [xml_translator] Querying XML for ID: %s", string_id)

		local res = xml_obj:query(query)
		if res[1] then
			local el = res[1]
			local el_text = xml_obj:getText(el)
			if el_text then
				xml_obj:setText(el, new_text)
				found_count = found_count + 1
				--printf("[DEBUG] [xml_translator] Translation applied for ID: %s", string_id)
			else
				printf("[WARNING] [xml_translator] Empty text for ID: %s", string_id)
			end
		else
			--printf("[WARNING] [xml_translator] Element not found for ID: %s", string_id)
			missing_count = missing_count + 1
		end
	end

	printf("[INFO] [xml_translator] Translations applied: %d found, %d missing", found_count, missing_count)
end

-- Функция для создания файла с переводами, если он отсутствует в missing_translations_rus
local function ensure_translation_file(xml_file_path)
	--printf("[DEBUG] [xml_translator] Ensuring translation file for: %s", xml_file_path)

	-- Извлекаем имя файла без расширения
	local base_name = xml_file_path:match("([^/\\]+)%.xml$")
	if not base_name then
		--printf("[ERROR] [xml_translator] Invalid XML file path: %s", xml_file_path)
		return nil
	end

	-- Путь к файлу в missing_translations_rus
	local missing_translation_path = string.format("gamedata\\scripts\\missing_translations_rus\\%s.lua", base_name)
	printf("[DEBUG] [xml_translator] Checking for missing translation file at: %s", missing_translation_path)

	-- Проверяем, существует ли файл в missing_translations_rus
	local missing_file = io.open(missing_translation_path, "r")
	if not missing_file then
		printf("[INFO] [xml_translator] Missing translation file not found: %s", missing_translation_path)

		-- Создаем файл, если он отсутствует
		local file = io.open(missing_translation_path, "w")
		if file then
			file:write("-- Translations for " .. base_name .. "\n")
			file:write("return {\n")
			file:write("    -- Add your translations here\n")
			file:write("}\n")
			file:close()
			printf(
				"[INFO] [xml_translator] Successfully created missing translation file: %s",
				missing_translation_path
			)
		else
			printf("[ERROR] [xml_translator] Failed to create missing translation file: %s", missing_translation_path)
			return nil
		end
	else
		missing_file:close()
		printf("[INFO] [xml_translator] Missing translation file already exists: %s", missing_translation_path)
	end
end

-- Callback для обработки XML
function on_xml_read()
	RegisterScriptCallback("on_xml_read", function(xml_file_name, xml_obj)
		printf("[INFO] [xml_translator] Callback triggered for file: %s", xml_file_name)

		-- Проверяем, что файл НЕ находится в text\eng
		if not xml_file_name:match("^text\\eng\\.+%.xml$") then
			--printf("[DEBUG] [xml_translator] Processing file (not in text\\eng): %s", xml_file_name)

			-- Загружаем переводы из applying_translate
			local applying_translations = load_applying_translations(xml_file_name)

			-- Применяем переводы из applying_translate
			local translations = get_translations_for_file(xml_file_name, applying_translations)
			if translations then
				printf("[INFO] [xml_translator] Applying translations for file: %s", xml_file_name)
				change_xml_text(xml_obj, translations)
			else
				printf("[WARNING] [xml_translator] No translations found for file: %s", xml_file_name)
			end
			return
		end

		-- Логика для файлов из text\eng
		printf("[DEBUG] [xml_translator] Processing file from text\\eng: %s", xml_file_name)

		-- Загружаем переводы из applying_translate
		local applying_translations = load_applying_translations(xml_file_name)

		-- Проверяем, есть ли файл в gamedata/configs/text/rus
		local rus_file_path = xml_file_name:gsub("text\\eng", "gamedata\\configs\\text\\rus")
		printf("[DEBUG] [xml_translator] Checking for Russian translation file at: %s", rus_file_path)

		local rus_file = io.open(rus_file_path, "r")
		if not rus_file then
			printf("[INFO] [xml_translator] Russian translation file not found: %s", rus_file_path)

			-- Файл в gamedata/configs/text/rus отсутствует, создаём его в missing_translations_rus
			ensure_translation_file(xml_file_name)
		else
			rus_file:close()
			printf("[INFO] [xml_translator] Russian translation file found: %s", rus_file_path)

			-- Загружаем переводы из gamedata/configs/text/rus или applying_translate
			local translations = get_translations_for_file(xml_file_name, applying_translations)
			if translations then
				printf("[INFO] [xml_translator] Applying translations for file: %s", xml_file_name)
				change_xml_text(xml_obj, translations)
			else
				printf("[WARNING] [xml_translator] No translations found for file: %s", xml_file_name)
			end
		end
	end)
end
